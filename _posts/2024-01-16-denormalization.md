---
title: 비정규화 언제 사용되나?
author: gyuhwan
date: 2024-01-14 16:50:00 +0800
categories: [DB, DB_Design]
tags: [denormalization]
---

정규화, 비정규화란 용어는 흔히 접했었고 정의에 대해서도 나름대로 학습을 했었다. **정규화**는 테이블 간 데이터의 중복을 허용하지 않는다는 것이고, **비정규화**는 정규화의 반대로 성능 향상, 데이터 검색 속도 증가를 위해 중복, 통합, 분할하는 과정이다.

일반적인 설계를 시작할 때 기본적으로 정규화를 했었다. 그게 당연하다고 생각했고 그 외엔 생각하지 못했다. 그러던 중 한 질문을 받았었는데. 

‘**비정규화를 사용할 때는 언제인거 같아요?**’ 

전혀 생각해보지 못했던 질문이었다. 중복을 허용할 때는 언제인거지? 조인을 덜 할테니 성능을 더 생각할 때인가? 그럼 중복으로 인해 더 안좋은거 아닌가? 그럼에도 사용할 때가 언제인걸까?

# 비정규화의 장단점

먼저 비정규화란 위에서 언급한 것처럼 정규화의 반대로 중복을 허용하는 기술이다. 예를 들어, 주문, 고객 테이블이 있다고 해보자. 

주문 내역과 고객의 이름이 필요한 상황이라면 항상 조인을 통해 고객 테이블의 정보를 가져오는 작업이 진행될 것이다. 이러한 조인을 줄이고자 주문 테이블 안에 고객의 이름을 칼럼을 추가한다.

덕분에 더 빠른 조회가 가능해질 것이다. 하지만 고객이 이름을 자주 개명하게 되면 어떻게 될까?

고객 테이블만 수정하는게 아닌 주문 테이블도 수정해야 할 것이다. 이 예시는 단순히 테이블 두 개지만 중복된 테이블이 많을 수록 장애가 발생할 확률이 높아진다.

![denormalization1](https://github.com/sghman/sghman.github.io/blob/main/assets/img/denormalization/Denormalization1.png?raw=true)

출처: https://www.splunk.com/en_us/blog/learn/data-denormalization.html

## 비정규화의 장점

- **향상된 쿼리 성능**
    
    데이터가 커지면 조인 작업을 통해 성능이 저하된다. 이때 자주 조회되는 데이터를 비정규화를 한다면 조인으로 인한 성능 저하는 없어지고 빠른 조회가 가능해진다.
    
- **단순한 데이터 모델**
    
    조인되는 쿼리 수를 줄이고 한 곳에 데이터를 관리하기 때문에 단순하게 유지가 가능해진다.
    
- **보고서 생성**
    
    사용 통계, 판매 보고서, 집계 등 많은 보고서를 빠르게 생성할 수 있다. 정규화되어 있다면 조인이나 집계를 통해 계산하는 작업이 발생하고 성능에 영향을 주게 되지만 비정규화를 통해 미리 계산된 값을 저장한다면 빠른 보고서 생성이 가능해진다.
    

## 비정규화의 단점

- **추가 저장 공간**
    
    밑에서 비정규화를 사용하기 위한 다양한 기술들을 살펴보겠지만, 비정규화는 추가적인 저장 공간을 필요로 한다. 
    
- **추가 문서**
    
    비정규화는 중복을 허용하는 작업일 확률이 높다. 그렇다면 데이터의 변경에 따른 영향이 이곳 저것으로 번질 수 있기 때문에 문서 작업을 통해 다른 개발자에게 전달하여 문제 발생을 줄여야 한다.
    
- **더 많은 코드**
    
    비정규화를 한다면 중복된 데이터로 인한 유효성 검증이나 추가적인 코드가 필요하게 될 것이다. 
    
- **느린 작업**
    
    비정규화는 데이터 검색 속도를 높일 수 있지만 동시에 업데이트 속도를 늦추게 된다. 
    

---

# 비정규화 기술들

비정규화를 하는 방법은 하나만이 아니다. 여러 가지 상황이 있을테고 거기에 맞게 사용할 수 있는 방법이 있다. 

## 파생되는 값이 자주 사용될 경우

쿼생쿼리 실행 중에 반복적으로 계산이 필요한 경우가 있다. 예를 들어, 학생 테이블의 국어, 영어, 수학 점수가 들어있는 테이블이 있다고 해보자. 

| 학생 | 국어 | 영어 | 수학 |
| --- | --- | --- | --- |
| A | 90 | 80 | 70 |
| B | 80 | 70 | 60 |
| C | 70 | 60 | 50 |

그런데 선생님이 필요한 값은 학생들의 총점이나 평균이다. 그래서 쿼리를 조회할 때마다 평균 값과 총점을 계산한다. 이때 평균 값과 총점은 파생되는 값이고 자주 사용된다. 비정규화를 통해 같이 저장해보자. 

| 학생 | 국어 | 영어 | 수학 | 총점 | 평균 |
| --- | --- | --- | --- | --- | --- |
| A | 90 | 80 | 70 | 240 | 80 |
| B | 80 | 70 | 60 | 210 | 70 |
| C | 70 | 60 | 50 | 180 | 60 |

## 테이블 사전 조인

테이블을 사전 조인이란, 비즈니스 가치가 없는 테이블에 열을 추가한다. 예를 들어, 카테고리 별로 모든 사용자의 메시지를 조회한다고 해보자. 이때 조인을 줄이기 위해 **User_messages** 테이블에 **category_name** 칼럼을 추가한다.

이제 User_messages의 테이블만 조회하면 카테고리별로 분류가 가능해진다. 주의할 점은 카테고리의 이름이 변경되면 User_messages의 칼럼의 이름도 변경해야 한다.

![denormalization2](https://github.com/sghman/sghman.github.io/blob/main/assets/img/denormalization/Denormalization2.png?raw=true)

출처: https://rubygarage.org/blog/database-denormalization-with-examples

## 파일이 여러 개일 때

보통 사용자가 첨부파일을 여러 개 첨부할 때, ‘뻐꾸기 외 3개’처럼 제일 첫 번째 파일 이름만 필요할 때가 있다. 이때 제일 첫 번재 이름만 마스터 테이블에 포함시킨다. 역시나 주의할 점은 파일이 수정될 때, 마스터의 첫 번째 첨부 파일 이름 칼럼도 수정되어야 한다.

![denormalization3](https://github.com/sghman/sghman.github.io/blob/main/assets/img/denormalization/Denormalization3.png?raw=true)

## 테이블 분할

테이블 분할은 큰 테이블을 조금 더 쉽게 쿼리하고 관리할 수 있도록 여러 개의 작은 테이블로 분해하는 프로세스이다. 파티션과는 조금 다르다. 

### 수평 테이블 분할

수평 테이블 분할이란, 특정 조건에 따라서 **행**을 여러 개의 작은 테이블로 나누는 것의 의미한다. 예를 들어, ‘고객’ 테이블을 가지고 있다고 해보자. 이 테이블은 고객 ID, 이름, 이메일, 거주 지역이 포함된다. 

고객이 점차 많아짐에 따라 혹은 요구사항을 위해 거주 지역별로 테이블을 분할하기로 결정했다고 해보자. 

| 고객ID | 이름 | 이메일 | 거주지 |
| --- | --- | --- | --- |
| 1 | 김철수 | 철수@example.com | 서울 |
| 2 | 이영희 | 영희@example.com | 부산 |
| 3 | 박지성 | 지성@example.com | 서울 |
| 4 | 최수지 | 수지@example.com | 부산 |

**서울에 거주하는 고객**

| 고객ID | 이름 | 이메일 | 거주지 |
| --- | --- | --- | --- |
| 1 | 김철수 | 철수@example.com | 서울 |
| 3 | 박지성 | 지성@example.com | 서울 |

**부산에 거주하는 고객**

| 고객ID | 이름 | 이메일 | 거주지 |
| --- | --- | --- | --- |
| 2 | 이영희 | 영희@example.com | 부산 |
| 4 | 최수지 | 수지@example.com | 부산 |

이렇게 데이터를 분할하면, 특정 지역에 대한 고객 정보를 더 빠르게 검색하고 관리할 수 있게 된다. 단, 전체 고객 데이터를 조회하거나 조인할 때는 성능이 저하될 수 있다. 이때는 뷰를 생성하여 관리하자.

### 수직 테이블 분할

수직 테이블 분할은 테이블의 **열**을 분할하는 방법이다. 테이블마다 자주 사용되는 칼럼이 있고 반대도 있을것이다. 이때 사용할 수 있는 방법인데. 예를 들어, ‘사원’ 테이블을 가지고 있다고 해보자.

이 테이블에는 사원 ID, 이름, 직무, 이메일이 포함되어 있다. 그런데 사원의 기본 정보만 필요하고 불필요한 이메일 정보는 필요하지 않다고 해보자. 이때 열을 기준으로 테이블을 분할한다.

| 사원ID | 이름 | 직무 | 이메일 |
| --- | --- | --- | --- |
| 1 | 김철수 | 개발자 | 철수@example.com |
| 2 | 이영희 | 디자이너 | 영희@example.com |
| 3 | 박지성 | 개발자 | 지성@example.com |
| 4 | 최수지 | 디자이너 | 수지@example.com |

**사원 기본 정보**

| 사원ID | 이름 |
| --- | --- |
| 1 | 김철수 |
| 2 | 이영희 |
| 3 | 박지성 |
| 4 | 최수지 |

**사원 이메일 정보**

| 사원ID | 이메일 |
| --- | --- |
| 1 | 철수@example.com |
| 2 | 영희@example.com |
| 3 | 지성@example.com |
| 4 | 수지@example.com |

---

# 비정규화를 언제해야 할까?

정규화는 데이터베이스 설계의 핵심 원칙 중 하나이다. 그 이유는 **DRY(Don't Repeat Yourself)** 원칙에 따라 중복된 데이터를 피하는 것이 문제를 발생시키는 것을 방지하기 때문이다. 그러나 특정 경우에는 비정규화가 필요할 수 있다.

비정규화를 고려하기 전에 먼저 검토해야 할 몇 가지 핵심 질문이 있다.

- **잘못 작성된 쿼리나 코드가 있지 않은가? 성능 향상을 위해 쿼리를 수정할 수 있는 여지는 없는지 검토해보자.**
- **인덱스를 통해 성능을 향상시킬 수 있는지 확인해보자.**
- **캐싱을 활용해 성능을 향상시킬 수 있는지 고려해보자.**
- **데이터가 자주 변경되는지 파악하자. 만약 그렇다면, 비정규화는 권장하지 않는다.**
- **CQRS(Command Query Responsibility Segregation) 패턴을 적용해 볼 만한 가치가 있는지 고민해보자.**

특히, 데이터가 자주 변경되지 않고, 보고서 제출용이 아닌 경우라면, 비정규화가 필요한지 꼼꼼하게 살펴보는 것이 중요하다. 다양한 자료를 통해 얻은 지식으로 보아, 비정규화는 반드시 필요한 경우에만 적용해야 함을 알 수 있었다.

참고 : 

https://guides.visual-paradigm.com/balancing-data-integrity-and-performance-normalization-vs-denormalization-in-database-design/

https://www.analyticsvidhya.com/blog/2022/08/database-normalization-a-step-by-step-guide-with-examples/

https://www.splunk.com/en_us/blog/learn/data-denormalization.html

https://rubygarage.org/blog/database-denormalization-with-examples